use std::evm::{Address, Ctx, StorageMap}
use std::evm::effects::assert

msg Erc721 {
    #[selector = 0x06fdde03]
    Name -> u256,

    #[selector = 0x95d89b41]
    Symbol -> u256,

    #[selector = 0x70a08231]
    BalanceOf { owner: Address } -> u256,

    #[selector = 0x6352211e]
    OwnerOf { token_id: u256 } -> Address,

    #[selector = 0x095ea7b3]
    Approve { to: Address, token_id: u256 },

    #[selector = 0x081812fc]
    GetApproved { token_id: u256 } -> Address,

    #[selector = 0x23b872dd]
    TransferFrom { from: Address, to: Address, token_id: u256 },

    #[selector = 0x40c10f19]
    Mint { to: Address, token_id: u256 },
}

struct NftStore {
    owner_of: StorageMap<u256, u256, 0>,
    approved: StorageMap<u256, u256, 1>,
    balances: StorageMap<Address, u256, 2>,
}

pub contract ERC721 uses (ctx: Ctx) {
    mut store: NftStore

    init() uses (mut store) {
        // StorageMaps are empty by default.
    }

    recv Erc721 {
        Name -> u256 { 0x46654e4654 }
        Symbol -> u256 { 0x46454e4654 }

        BalanceOf { owner } -> u256 uses (store) {
            store.balances.get(key: owner)
        }

        OwnerOf { token_id } -> Address uses (store) {
            let owner_inner = store.owner_of.get(key: token_id)
            assert(owner_inner != 0)
            Address { inner: owner_inner }
        }

        Approve { to, token_id } uses (mut store, ctx) {
            let owner_inner = store.owner_of.get(key: token_id)
            assert(owner_inner != 0)
            assert(owner_inner == ctx.caller().inner)
            store.approved.set(key: token_id, value: to.inner)
        }

        GetApproved { token_id } -> Address uses (store) {
            Address { inner: store.approved.get(key: token_id) }
        }

        TransferFrom { from, to, token_id } uses (mut store, ctx) {
            assert(to != Address::zero())

            let owner_inner = store.owner_of.get(key: token_id)
            assert(owner_inner == from.inner)

            let caller = ctx.caller()
            let approved_inner = store.approved.get(key: token_id)
            assert(caller.inner == owner_inner || caller.inner == approved_inner)

            store.owner_of.set(key: token_id, value: to.inner)
            store.approved.set(key: token_id, value: 0)

            let from_bal = store.balances.get(key: from)
            assert(from_bal > 0)
            store.balances.set(key: from, value: from_bal - 1)
            store.balances.set(key: to, value: store.balances.get(key: to) + 1)
        }

        Mint { to, token_id } uses (mut store) {
            assert(to != Address::zero())

            let owner_inner = store.owner_of.get(key: token_id)
            assert(owner_inner == 0)

            store.owner_of.set(key: token_id, value: to.inner)
            store.balances.set(key: to, value: store.balances.get(key: to) + 1)
        }
    }
}
